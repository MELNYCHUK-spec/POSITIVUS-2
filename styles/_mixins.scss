  @mixin fluid-text($max:48,$min:16){
  font-size: clamp(#{$min}px, #{calc($max / 1240) * 100}vw, #{$max}px);
  //функция сlamp задает размер шрифта минимальным,
  // если экран слишком мал,
  // максимальным, если экран слишком велик,
  // и адаптивным в промежуточных размерах, в зависимости от ширины окна просмотра.

  //#{$min}px — это интерполяция переменной $min в SCSS.
  // Значение переменной $min заменяется на число, после чего добавляется единица измерения px (пиксели).
  // Это минимальный размер шрифта, который не будет меньше заданного.

  // Среднее значение (#{calc($max / 1240) * 100}vw)
  //Здесь создается динамическое значение для ширины шрифта, которое изменяется в зависимости от ширины экрана:
  //
  //$max / 1240 — это деление максимального значения шрифта $max на 1240.
  // Обычно предполагается, что 1240 — это ширина контейнера макета в пикселях, при которой устанавливается оптимальный размер шрифта.
  //
  //calc($max / 1240) * 100 — внутри calc() происходит вычисление, которое приводит к значению, пропорциональному ширине экрана.
  // Результат умножается на 100, чтобы это значение стало процентным выражением ширины экрана.
  //
  //vw — это единица измерения, которая представляет собой процент от ширины вьюпорта (экранной области).
  // Таким образом, вычисляемый размер шрифта будет изменяться в зависимости от ширины экрана, но пропорционально максимальному размеру шрифта $max.

  //. Максимальный размер шрифта (#{$max}px)
  //#{$max}px — это максимальное значение для шрифта, которое не будет превышено, даже если ширина экрана очень велика.
  // Оно интерполируется с переменной $max, которая задаёт максимальный размер шрифта, и добавляется единица измерения px.

  //Когда используется clamp(), браузер выбирает значение шрифта в зависимости от ширины экрана:
  //
  //Если ширина экрана слишком мала, шрифт будет равен минимальному значению $min.
  //Если ширина экрана достаточно велика, шрифт будет равен максимальному значению $max.
  //В промежуточных случаях браузер вычисляет размер шрифта, пропорциональный ширине экрана, но не ниже $min и не выше $max.

  //Если:
  //
  //$min: 16px
  //$max: 42px
  //Тогда для экрана шириной 1240px или больше, шрифт будет равен 42px.
  // Для экрана шириной 640px, шрифт будет уменьшаться, пропорционально ширине экрана, но не станет меньше 16px.

}

  @mixin flex-center($isInline:false){ // по умолчанию значение параметра:false, то есть блочный флекс контейнер.
    @if $isInline{
      display:inline-flex;
    } @else {
      display:flex;
    }
    justify-content: center;
    align-items: center;
  }

  //Миксин flex-center предназначен для упрощения работы с флексбокс-выравниванием элементов в CSS.
  // Он используется для того, чтобы централизовать содержимое элемента как по горизонтали, так и по вертикали,
  // с возможностью выбора между обычным флекс-контейнером и инлайн-флекс-контейнером.

  //$isInline — это булевый параметр миксина в SCSS. Она используется для того, чтобы передавать в миксин значение, которое будет влиять на поведение CSS-свойств.
  //
  //В данном случае, $isInline — это параметр миксина flex-center, который задаёт, будет ли элемент флекс-контейнером с обычным или инлайн-блоковым поведением.
  //
  //$isInline: false — по умолчанию параметр имеет значение false, что означает, что элемент будет использовать свойство display: flex (то есть обычный блочный флекс-контейнер).
  //$isInline: true — если ты передашь значение true, элемент будет использовать свойство display: inline-flex, что сделает его инлайн-флекс-контейнером (он будет вести себя как строчный элемент, но с флекс-выравниванием).

  //Булевый параметр — это тип данных, который может иметь два возможных значения: true (истина) или false (ложь).
  // Это удобно для условных операторов, которые изменяют поведение миксина в зависимости от переданного значения.
  //Ты можешь использовать условные операторы (@if и @else), чтобы изменить логику в зависимости от этого значения.
  //В случае с SASS это позволяет контролировать поведение стилей более гибко, используя простые булевы условия.

  @mixin abs-center{
    position: absolute;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
  }

  // миксин abs-center предназначен для абсолютного центрирования элемента по горизонтали и вертикали внутри родительского контейнера.
  // Он работает за счёт комбинации position: absolute, задания координат top и left со значением 50%,
  // и корректировки позиции с помощью transform: translate(-50%, -50%).

  //position: absolute:

  //Элемент позиционируется относительно ближайшего родителя с position: relative, absolute, fixed, или sticky.
  //top: 50% и left: 50%:

  //Сдвигают элемент в точку, где его верхний левый угол находится в центре родительского элемента.
  //transform: translate(-50%, -50%):

  //Сдвигает элемент на половину его ширины и высоты в обратную сторону, чтобы центр элемента совпал с центром родителя.

  @mixin square($size) {
    width: $size;
    aspect-ratio: 1;
  }

  //Миксин square в твоем примере используется для создания элементов с одинаковыми шириной и высотой, обеспечивая квадратную форму.
  // Он принимает один параметр $size, который задает размер элемента. С помощью CSS-свойства aspect-ratio устанавливается соотношение сторон 1:1,
  // что гарантирует, что высота элемента всегда будет равна его ширине.
  //width: $size; — устанавливает ширину элемента в зависимости от переданного значения $size.
  //aspect-ratio: 1; — это новое свойство CSS, которое задает соотношение сторон. Значение 1 означает,
  // что высота будет всегда равна ширине (то есть элемент всегда будет квадратным).

  //Параметр — это входное значение, которое передается в миксин при его вызове. (в примере в миксине square($size)) $size -- это параметр
  // Параметры задаются в круглых скобках при определении миксина, и они могут иметь значения по умолчанию или быть обязательными.

  //Переменная — это значение, которое определяешь и используешь внутри файла, но не передаешь в функцию или миксин.
  // Переменные обычно определяются где-то в коде и используются в других местах для хранения значений.


  //$primary-color: #3498db;  // Переменная, которая хранит значение цвета

  //.button {
  //background-color: $primary-color;  // Использование переменной для задания фона

  //$primary-color: #3498db; — это переменная SASS, которая хранит значение цвета.
  //Мы используем эту переменную в классе .button, чтобы адать свойство background-color.

    @mixin visually-hidden{
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    margin: -1px !important;
    border:0 !important;
    padding: 0 !important;
    white-space: nowrap !important;
    clip-path: inset(100%) !important;
    overflow: hidden !important;
  }

  //Этот миксин visually-hidden используется для создания скрытых элементов, которые остаются доступными для скринридеров
  // (технологий для людей с ограниченными возможностями), но не видны пользователям.

  //position: absolute !important;:
  //
  //Элемент позиционируется абсолютно относительно его ближайшего относительно позиционированного родителя (или относительно окна браузера).
  // Это помогает элементу быть выведенным за пределы видимой области, но не занимать места на странице.

  //width: 1px !important;:
  //
  //Устанавливает ширину элемента равной 1 пикселю, что делает его фактически невидимым, но он всё ещё занимает минимальное пространство.
  //height: 1px !important;:
  //
  //Подобно ширине, устанавливает высоту в 1 пиксель.
  //margin: -1px !important;:
  //
  //Отрицательные отступы помогают "вывести" элемент за пределы его родителя, ещё больше уменьшая его визуальное воздействие на страницу.
  //border: 0 !important;:
  //
  //Убирает любые границы, чтобы они не занимали пространство или не оставляли следов.
  //padding: 0 !important;:
  //
  //Убирает внутренние отступы, чтобы элемент не занимал лишнее пространство.
  //white-space: nowrap !important;:
  //
  //Устанавливает, что содержимое элемента не будет переноситься, что дополнительно помогает минимизировать его влияние на макет.
  //clip-path: inset(100%) !important;:
  //
  //Это старое свойство, которое также скрывает элемент, устанавливая его видимую область на ноль. Это делает элемент невидимым для всех, кроме скринридеров.
  //overflow: hidden !important;:
  //
  //Прячет все содержимое, которое выходит за пределы установленного размера элемента.

  //clip-path: Это свойство CSS позволяет обрезать элемент, определяя его видимую область. Все, что выходит за пределы этой области, будет скрыто.
  //inset(100%): Функция inset() определяет прямоугольную область, внутри которой будет виден элемент.
  // В случае 100% отступы от всех сторон (сверху, справа, снизу, слева) будут установлены на 100% размера элемента,
  // что фактически означает полное скрытие содержимого.

  @mixin reset-link{
    color:inherit;
    &,
    &:hover {
      text-decoration: none;
    }
  }